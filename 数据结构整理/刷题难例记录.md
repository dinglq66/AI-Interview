# 刷题难例记录

# 1、NC91 **最长上升子序列(三)**

- 考察动态规划 + 二分法

## 描述

给定数组 arr ，设长度为 n ，输出 arr 的最长上升子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）

数据范围：0≤n≤200000,0≤$arr_i$≤1000000000

要求：空间复杂度 O*(*n*)，时间复杂度 O*(nlogn)

## 示例1

输入：

```
[2,1,5,3,6,4,8,9,7]
```

复制

返回值：

```
[1,3,4,8,9]
```

复制

## 示例2

输入：

```
[1,2,8,6,4]
```

复制

返回值：

```
[1,2,4]
```

复制

说明：

```
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4）         
```

## 备注：

```
n≤10^5
1≤arr_i≤10^9
```

## 代码实现：

```c++
class Solution {
  public:
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型vector the array
     * @return int整型vector
     */
    vector<int> LIS(vector<int>& arr) {
        // write code here
        int n = arr.size();
        vector<int> tail(n); //贪心的希望末尾的数字越小越好
        vector<int> curLen(n); //arr的第i个元素对应的最大递增子序列长度
        int ans = 0;
        for (int i = 0; i < n; i ++) {
            int left = 0, right = ans;
            while (left < right) { //找第一个大于等于arr[i]的位置
                int mid = left + (right - left) / 2;
                if (tail[mid] >= arr[i]) right = mid;
                else left = mid + 1;
            }
            tail[left] = arr[i];
            curLen[i] = left + 1; //当前元素对应最大递增子序列的长度
            if (left == ans) ans ++;
        }
        vector<int> res(ans);
        for (int i = arr.size() - 1, j = ans; i >= 0; i --) {
            if (curLen[i] == j) res[-- j] = arr[i];
        }
        return res;
    }
};
```

时间复杂度：O(nlogn)

空间复杂度：O(n)

> 该题主要难点在于如何降低动态规划过程中得到当前位置最长升序子序列长度的时间复杂度，O(n^2)容易实现，但是会超时。这里tail数组的引入思想比较关键