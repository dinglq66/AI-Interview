# 刷题难例记录

# 1、NC91 **最长上升子序列(三)**

- 考察动态规划 + 二分法

## 描述

给定数组 arr ，设长度为 n ，输出 arr 的最长上升子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）

数据范围：0≤n≤200000,0≤$arr_i$≤1000000000

要求：空间复杂度 O*(*n*)，时间复杂度 O*(nlogn)

## 示例1

输入：

```
[2,1,5,3,6,4,8,9,7]
```

返回值：

```
[1,3,4,8,9]
```

## 示例2

输入：

```
[1,2,8,6,4]
```

返回值：

```
[1,2,4]
```

说明：

```
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4）         
```

## 备注：

```
n≤10^5
1≤arr_i≤10^9
```

## 代码实现：

```c++
class Solution {
  public:
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型vector the array
     * @return int整型vector
     */
    vector<int> LIS(vector<int>& arr) {
        // write code here
        int n = arr.size();
        vector<int> tail(n); //贪心的希望末尾的数字越小越好
        vector<int> curLen(n); //arr的第i个元素对应的最大递增子序列长度
        int ans = 0;
        for (int i = 0; i < n; i ++) {
            int left = 0, right = ans;
            while (left < right) { //找第一个大于等于arr[i]的位置
                int mid = left + (right - left) / 2;
                if (tail[mid] >= arr[i]) right = mid;
                else left = mid + 1;
            }
            tail[left] = arr[i];
            curLen[i] = left + 1; //当前元素对应最大递增子序列的长度
            if (left == ans) ans ++;
        }
        vector<int> res(ans);
        for (int i = arr.size() - 1, j = ans; i >= 0; i --) {
            if (curLen[i] == j) res[-- j] = arr[i];
        }
        return res;
    }
};
```

时间复杂度：O(nlogn)

空间复杂度：O(n)

> 该题主要难点在于如何降低动态规划过程中得到当前位置最长升序子序列长度的时间复杂度，O(n^2)容易实现，但是会超时。这里tail数组的引入思想比较关键

# 2、NC87 丢棋子问题

## 描述

一座大楼有 n+1 层，地面算作第0层，最高的一层为第 n 层。已知棋子从第0层掉落肯定不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎。 

给定整数 n 作为楼层数，再给定整数 k 作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最小次数。一次只能扔一个棋子。 

数据范围： 1≤i≤n, k≤$10^6$

要求：空间复杂度 O(k)*O*(*k*)，时间复杂度 O(km)(m是最终返回的结果) 

## 示例1

```
输入：10,1
返回值：10
说明：因为只有1棵棋子，所以不得不从第1层开始一直试到第10层，在最差的情况下，即第10层是不会摔坏的最高层，最少也要扔10次
```

## 示例2

```
输入：3,2
返回值：2
说明：先在2层扔1棵棋子，如果碎了，试第1层，如果没碎，试第3层
```

## 示例3

```
输入：105,2
返回值：14
说明：第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13层
若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26层
若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38层
若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49层
若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59层
若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68层
若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76层
若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83层
若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89层
若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94层
若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98层
若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101层
若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103层
若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果
```

## 代码实现：

### 解法一：简单的记忆化DFS（时间复杂度较高）

### 实现思路

首先我们假设在第i层扔了棋子后，面临的两种情况为：

1、棋子碎了

> 那么我们棋子的个数要减少一个，楼层搜索的区间从[1, n]变为[1, i-1]

2、棋子没有碎

> 那么我们棋子的个数不变，但是楼层从[1, n]变成了[i+1, n]

然后这个是对于我们每一层的两种情况，我们每次为了找到最坏的一个情况，需要再所有的楼层中选择一个最坏的情况，所以我们每次dfs的时候，还需要进行的操作就是在所有楼层中找到最坏的一个情况，然后我们如何判断当前楼的最坏情况呢？事实上，当前的这层楼只会出现我们上述的两种情况，棋子碎了和棋子没有碎，根据这两种情况，分别进入下一重dfs，然后我们为了减少重复计算，就可以把目前已经算过的棋子和楼层数记录下来，这样我们的递归终止条件就很明显了，第一个就是当我们只有一个棋子的时候，和当我们没有楼层或者某一对鸡蛋数目和楼层数目我们曾经已经记录过了，就可以直接返回值。那么我们的记忆化搜索的代码就可以写为：

```c++
class Solution {
    map<pair<int, int>, int> mp;
    
// pair里面第一个存的是楼层数，第二个存的是棋子数
   public:
    int dfs(int n, int k) {
        if (k == 1) return n;
        if (n == 0) return 0;
//         这个是只有一个棋子和没有楼层
        if (mp[{n, k}]) return mp[{n, k}];
//         如果这个之前出现过
        int res = INT_MAX;
        for (int i = 1; i <= n; i++)
            res = min(res, max(dfs(n - i, k), dfs(i - 1, k - 1)) + 1);
//         因为我们要求取的是最坏的情况，所以我们要去一个最大值
        mp[{n, k}] = res;
//         记录一下
        return res;
    }
    int solve(int n, int k) { return dfs(n, k); }
};
```

### 时空复杂度分析

- 时间复杂度：$O(k*n^2*log(nk))$

  理由如下：我们记忆化过程中最坏的情况是把所有的情况都遍历到，也就是k*n，但是这里时间复杂度不仅仅是k\*n，我们还需要考虑到每次dfs内都会进行一次循环，那么我们整体的时间复杂度就需要再乘上一个n，这里还没有结束，由于我们使用了一个map来存储所有的情况，那么存储过程还包含一个log的复杂度。

- 空间复杂度：$O(k*n)$

  理由如下：需要存储所有的可能情况

### 解法二：重新定义状态方程

### 实现思路

我们第一种实现方法中实际上就是一个穷举的思想，我们需要对上述过程进行优化。那么我们可以反向来思考这个问题，我们可以创建一个二维数组，数组第一维表示手上还有几颗棋子，第二维则表示，最多允许丢棋子的次数，然后数组值表示能够达到的最高层数。当数组中第k行中的某一列第一次大于了所需要的楼层n，这一列的索引号就是我们要找的m。

> 上述描述可以理解为：用手上的k颗棋子，在扔m次的情况下达到的最大楼层数超过了n，并且m-1次达不到n层，那么对于n层楼的问题来说，最坏的情况下也要扔到的最少次数恰是m

然后我们可以进一步发现有两个特点：

1. 无论在哪一层丢棋子，棋子只可能是碎了或者没有碎，碎了就是向楼下找，没碎就是向楼上找
2. 无论上下楼，总的楼层数 = 楼上层数 + 楼下层数 + 1

那我们再明确下动态规划数组DP的含义是什么？

比如我们有一个` dp[k][m]=n`，这个代表我们当前有k个棋子，最多可以扔m次，在最坏的情况下可以完整测试一栋层数为n的楼。

状态关系表现为，用k枚棋子扔m次能达到的最高楼层应该等于k-1枚棋子扔m-1次能测试的楼层（碎了，向下的楼层） + k枚棋子扔m-1次能测试的楼层 （没碎，向上的楼层）+ 1（当前楼层）

```c++
dp[k][m] = dp[k-1][m-1] + d[k][m-1] + 1
```

求解问题的完整代码如下：

```c++
class Solution {
   public:
    int solve(int n, int k) {
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
        int m = 0;
        while (dp[k][m] < n) {
            m++;
            for (int i = 1; i <= k; i++)
                dp[i][m] = dp[i][m - 1] + dp[i - 1][m - 1] + 1;
        }
//         满足条件的方程
        return m;
    }
};
```

### 时空复杂度分析

- 时间复杂度：$O(k*m)$

  理由如下：k是我们棋子的数量，m是至少丢棋子的次数，满足条件时就跳出循环，不用完整的k*n

- 空间复杂度：$O(k*n)$

  理由如下：存储了所有的可能情况

在上述代码实现过程中，用二维数组来实现动态规划的空间复杂度是比较高的，运行时会超出内存限制，可以考虑用递归的方法来重写上述的状态转移方程

### 代码实现如下：

```c++
class Solution {
  public:
    int dfs(int k, int m) {
        if (m == 1 or k == 1) return m;
        return dfs(k - 1, m - 1) + dfs(k, m - 1) + 1;
        // 这个就是把状态转移方程变成递归形式
    }

    int solve(int n, int k) {
        int m = 1;
        while (dfs(k, m) < n) m++;
        // 寻找m次
        return m;
    }
};
```

### 时空复杂度分析：

- 时间复杂度：$O(k*m)$

  理由如下：k是我们的棋子数量，m是我们至少丢棋子的数量，满足条件即跳出循环

- 空间复杂度：$O(m)$

  理由如下：系统的递归栈

> 总结：该问题的主要难点在于状态转移方程的确定，同时还需要注意对算法空间复杂度的优化，递归终止条件的确定要比较明确